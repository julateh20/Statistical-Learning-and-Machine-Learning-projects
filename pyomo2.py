# -*- coding: utf-8 -*-
"""pyomo2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cmFGnFsBXsukArqwS4SHCMuHaJusOkie
"""

from google.colab import drive
drive.mount('/content/drive')

!ls "/content/drive/My Drive"

!pip install -q pyomo

import pyomo.environ as pyo
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.neighbors import DistanceMetric

pip install geopandas

pip install shapely

df_dados= pd.read_csv('/content/drive/My Drive/Dalarnamunii.csv')
df_dados.head(15)

df_dados.columns

# Declaração do modelo:
modelo2 = pyo.ConcreteModel()

# Matriz de distâncias:
dist = DistanceMetric.get_metric('euclidean')
dij = df_dados[['X', 'Y']].to_numpy()
dij = dist.pairwise(dij)
    
# Índices:
modelo2.M = range(len(dij))
modelo2.N = range(len(dij))
# Parâmetros:
modelo2.d = pyo.Param(modelo2.M, modelo2.N, initialize=lambda modelo, i, j: dij[i][j])
p = 3

# Vetores de demanda e capacidade
Ci = list(df_dados.Demand)
#Kj = list(df_dados.Capacity)
modelo2.C = pyo.Param(modelo2.M, initialize=lambda modelo2, i: Ci[i])
#modelo2.K = pyo.Param(modelo2.N, initialize=lambda modelo2, j: Kj[j])

# Variáveis de decisão:
modelo2.y = pyo.Var(modelo2.N, within=pyo.Binary)
modelo2.x = pyo.Var(modelo2.M, modelo2.N, within=pyo.Binary)

# Função objetivo:
def f_obj(modelo):
    return sum(modelo.C[i] * modelo.x[i,j] * modelo.d[i,j] for i in modelo.M for j in modelo.N)

modelo2.obj = pyo.Objective(rule=f_obj, sense=pyo.minimize)

# Sujeito a:

modelo2.restricao_a = pyo.Constraint(expr=sum(modelo2.y[j] for j in modelo2.N) == p)

modelo2.restricao_b = pyo.ConstraintList()
for i in modelo2.M:
    modelo2.restricao_b.add(sum(modelo2.x[i,j] for j in modelo2.N) == 1.0)

modelo2.restricao_c = pyo.ConstraintList ()
for i in modelo2.M: 
    for j in modelo2.N: 
        modelo2.restricao_c.add (modelo2.x [i, j] <= modelo2.y [j])

!apt-get install -y -qq glpk-utils

!apt-get install -y -qq coinor-cbc

result = pyo.SolverFactory ('cbc', executable='/usr/bin/cbc'). solve (modelo2) 
print (result)

# Medianas
list_y = list(modelo2.y.keys())
dados_modelo2 = df_dados.copy()
dados_modelo2['Mediana'] = [modelo2.y[i]() for i in list_y]

# Alocações:
list_x = list(modelo2.x.keys())
alocacoes = [i for i in list_x if modelo2.x[i]() == 1]
alocacoes.sort(key=lambda x:x[0])
medianas = [alocacao[1] for alocacao in alocacoes]
dados_modelo2 ['Alocacao'] = medianas

# Distância
dados_modelo2['Distancia'] = [dij[alocacao[0], alocacao[1]] for alocacao in alocacoes]

dados_modelo2

dados_modelo2['Distancia_total'] = dados_modelo2['Distancia'] * dados_modelo2['Demand']
dados_modelo2

plt.figure(figsize=(12, 6))
plot = sns.scatterplot(data=dados_modelo2, 
                       x="X", y="Y", 
                       hue="Alocacao", 
                       size='Demand',  
                       sizes=(50, 250),
                       alpha=.7,
                       palette="tab10")
highlights = dados_modelo2[dados_modelo2.index == dados_modelo2.Alocacao]
for index, row in highlights.iterrows():
    plot.text(row['X']+3, row['Y'], row['Alocacao'], horizontalalignment='left')

dados_modelo2_resumo = dados_modelo2.copy()
resumo2 = dados_modelo2_resumo.groupby('Alocacao', as_index=False).agg({"Demand": "sum", 
                                                        "Distancia": "sum", 
                                                        "Distancia_total": "sum"})
sum_dist2 = resumo2.Distancia.sum()
sum_dist_total2 = resumo2.Distancia_total.sum()
print("Distância:", sum_dist2)
print("Distância_total:", sum_dist_total2)